package io.github.kr8gz.simpletasks.config;

import com.electronwill.nightconfig.core.Config;
import com.electronwill.nightconfig.core.ConfigSpec;
import com.electronwill.nightconfig.core.file.FileNotFoundAction;
import com.electronwill.nightconfig.core.io.ConfigParser;
import com.electronwill.nightconfig.core.io.ParsingException;
import com.electronwill.nightconfig.yaml.YamlFormat;
import io.github.kr8gz.simpletasks.SimpleTasks;

import java.io.ByteArrayInputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class SimpleTasksConfig {
    private static final Path PATH = Paths.get("config", SimpleTasks.MOD_ID + ".yml");
    private static final StringBuilder TEMPLATE = new StringBuilder("# Template generated by SimpleTasks\n");

    private static final ConfigSpec spec = new ConfigSpec();
    private static final ConfigParser<?> yamlParser = YamlFormat.defaultInstance().createParser();
    private static Config config = YamlFormat.newConfig();

    public static class Entry<T> {
        final String key;
        final T defaultValue;
        final Predicate<Object> validator;

        private Entry(String key, T defaultValue, Predicate<Object> validator) {
            this.key = key;
            this.defaultValue = defaultValue;
            this.validator = validator;

            this.defineSpec();
            TEMPLATE.append("\n%s\n".formatted(getTemplate()));
        }

        void defineSpec() {
            spec.define(key, defaultValue, validator);
        }

        public T get(boolean reload) {
            if (reload) reload();
            return config.get(key);
        }

        String getTemplate() {
            return "%s: %s".formatted(key, defaultValue);
        }
    }

    public static class ListEntry<T> extends Entry<List<T>> {
        private ListEntry(String key, List<T> defaultValue, Predicate<Object> validator) {
            super(key, defaultValue, validator);
        }

        @Override
        void defineSpec() {
            spec.defineList(key, defaultValue, validator);
        }

        @Override
        public List<T> get(boolean reload) {
            return new ArrayList<>(super.get(reload));
        }

        @Override
        String getTemplate() {
            var list = defaultValue.isEmpty() ? "\n#  - ..." : defaultValue.stream()
                    .map("\n  - %s"::formatted)
                    .collect(Collectors.joining());

            return "%s:%s".formatted(key, list);
        }
    }

    public static final ListEntry<String> TASKS = new ListEntry<>("tasks", new ArrayList<>(List.of("Example task")), v -> v instanceof String task && !task.isEmpty());
    public static final Entry<Boolean> ASSIGN_UNIQUE_TASKS = new Entry<>("assignUniqueTasks", false, v -> v instanceof Boolean);

    public static void reload() {
        try {
            Files.createDirectories(PATH.getParent());
            var templateStream = new ByteArrayInputStream(TEMPLATE.toString().getBytes(StandardCharsets.UTF_8));
            config = yamlParser.parse(PATH, FileNotFoundAction.copyData(templateStream));
            spec.correct(config);
        } catch (ParsingException e) {
            SimpleTasks.LOGGER.warn("Parsing %s failed. Continuing with previous (or empty) task list".formatted(PATH));
        } catch (Exception e) {
            SimpleTasks.LOGGER.error("Exception while getting tasks config:", e);
        }
    }
}
